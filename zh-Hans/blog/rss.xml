<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>SeekYou Blog</title>
        <link>https://2seekyou.github.io/zh-Hans/blog</link>
        <description>SeekYou Blog</description>
        <lastBuildDate>Thu, 29 Feb 2024 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>zh-Hans</language>
        <item>
            <title><![CDATA[About DBSCAN]]></title>
            <link>https://2seekyou.github.io/zh-Hans/blog/DBSCAN</link>
            <guid>https://2seekyou.github.io/zh-Hans/blog/DBSCAN</guid>
            <pubDate>Thu, 29 Feb 2024 00:00:00 GMT</pubDate>
            <description><![CDATA[记录一下最近了解的聚类算法：DBSCAN]]></description>
            <content:encoded><![CDATA[<p>记录一下最近了解的聚类算法：DBSCAN</p>
<p>DBSCAN is a density-based clustering algorithm that groups together data points that are closely packed, while marking points that lie alone in low-density regions as outliers.</p>
<p>Unlike K-means, DBSCAN doesn't require specifying the number of clusters beforehand and is robust to noise and outliers. Along with its hierarchical extensions HDBSCAN, it is applied mostly in Automotive Radar Data.
最近对有关雷达数据的聚类方法做了些调研，主要看的一些评估指标和有关DBSCAN的方法，于此重新复习一下DBSCAN。文件附上：
<a href="https://2seekyou.github.io/zh-Hans/blog/RESEARCH-ON-RADAR-DATA-CLUSTERING.pdf">pdf文件</a></p>
<p>和K-Means，BIRCH这些一般只适用于凸样本集的聚类相比，DBSCAN既可以适用于凸样本集，也可以适用于非凸样本集。下面我们就对DBSCAN算法的原理做一个总结。</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">凸集 (Convex Set):对于该集合中的任意两点，连接它们的线段上的所有点也都包含在该集合中。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">凹集 (Concave Set):对于该集合中的任意两点，连接它们的线段上的所有点也都不在该集合中。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="clustering">Clustering<a href="https://2seekyou.github.io/zh-Hans/blog/DBSCAN#clustering" class="hash-link" aria-label="Clustering的直接链接" title="Clustering的直接链接">​</a></h2>
<p>聚类算法主要有 4 大类：</p>
<ul>
<li>Centroid-based Clustering<br>
<!-- -->基于质心的聚类从许多随机定位的质心（中心点）开始，这些质心充当所找到簇的中心。这些质心被一步步细化，直到它们收敛到簇的真正中心。</li>
<li>Density-based Clustering<br>
<!-- -->基于密度的聚类组按其附近其他点的密度进行分组。真正靠近的点将形成一个簇，而孤立的点将被标记为异常值</li>
<li>Distribution-based Clustering<br>
<!-- -->基于分布的聚类首先假设每个聚类都由从已知分布（通常是正态分布）中采样的点组成。该算法的目标是找到每个聚类的分布参数</li>
<li>Hierarchical Clustering<br>
<!-- -->很多情况下的簇并不像我们看到的示例那样清晰地分开。它们通常由较小的组组成，这些组可以组合在一起形成一个更大的簇，最终得到一个包罗万象的簇。</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="dbscan基本概念">DBSCAN基本概念<a href="https://2seekyou.github.io/zh-Hans/blog/DBSCAN#dbscan%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" class="hash-link" aria-label="DBSCAN基本概念的直接链接" title="DBSCAN基本概念的直接链接">​</a></h2>
<p>DBSCAN的基本概念可以用1，2，3，4来总结。</p>
<ul>
<li>
<p>1个核心思想：基于密度。直观效果上看，DBSCAN算法可以找到样本点的全部密集区域，并把这些密集区域当做一个一个的聚类簇。</p>
</li>
<li>
<p>2个算法参数：邻域半径R和最少点数目MinPoints。这两个算法参数实际可以刻画什么叫密集：当邻域半径R内的点的个数大于最少点数目MinPoints时，就是密集</p>
</li>
<li>
<p>3种点的类别：核心点，边界点和噪声点。邻域半径R内样本点的数量大于等于minpoints的点叫做核心点。</p>
</li>
</ul>
<p>不属于核心点但在某个核心点的邻域内的点叫做边界点。既不是核心点也不是边界点的是噪声点</p>
<p><a href="https://img.tg/image/OyvyxD" target="_blank" rel="noopener noreferrer"><img loading="lazy" src="https://ooo.0x0.ooo/2024/02/28/OyvyxD.md.png" alt="OyvyxD.md.png" class="img_ev3q"></a></p>
<ul>
<li>4种点的关系：密度直达，密度可达，密度相连，非密度相连。</li>
</ul>
<p>如果P为核心点，Q在P的R邻域内，那么称P到Q密度直达。任何核心点到其自身密度直达，密度直达不具有对称性，如果P到Q密度直达，那么Q到P不一定密度直达。</p>
<p>如果存在核心点P2，P3，……，Pn，且P1到P2密度直达，P2到P3密度直达，……，P(n-1)到Pn密度直达，Pn到Q密度直达，则P1到Pn(n=1,2...),Q密度可达。密度可达也不具有对称性。</p>
<p><a href="https://img.tg/image/OyvgJF" target="_blank" rel="noopener noreferrer"><img loading="lazy" src="https://ooo.0x0.ooo/2024/02/28/OyvgJF.md.png" alt="OyvgJF.md.png" class="img_ev3q"></a></p>
<p>如果存在核心点S，使得S到P和Q都密度可达，则P和Pn(n=1,2...),Q密度相连。密度相连具有对称性，如果P和Q密度相连，那么Q和P也一定密度相连。密度相连的两个点属于同一个聚类簇。</p>
<p>如果两个点不属于密度相连关系，则两个点非密度相连。非密度相连的两个点属于不同的聚类簇，或者其中存在噪声点</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="dbscan聚类思想">DBSCAN聚类思想<a href="https://2seekyou.github.io/zh-Hans/blog/DBSCAN#dbscan%E8%81%9A%E7%B1%BB%E6%80%9D%E6%83%B3" class="hash-link" aria-label="DBSCAN聚类思想的直接链接" title="DBSCAN聚类思想的直接链接">​</a></h2>
<p>DBSCAN的聚类定义很简单：由密度可达关系导出的最大密度相连的样本集合，即为我们最终聚类的一个类别，或者说一个簇。</p>
<p>这个DBSCAN的簇里面可以有一个或者多个核心对象。如果只有一个核心对象，则簇里其他的非核心对象样本都在这个核心对象的ϵϵ-邻域里；如果有多个核心对象，则簇里的任意一个核心对象的ϵϵ-邻域中一定有一个其他的核心对象，否则这两个核心对象无法密度可达。这些核心对象的ϵϵ-邻域里所有的样本的集合组成的一个DBSCAN聚类簇。</p>
<p>那么怎么才能找到这样的簇样本集合呢？DBSCAN使用的方法很简单，它任意选择一个没有类别的核心对象作为种子，然后找到所有这个核心对象能够密度可达的样本集合，即为一个聚类簇。接着继续选择另一个没有类别的核心对象去寻找密度可达的样本集合，这样就得到另一个聚类簇。一直运行到所有核心对象都有类别为止。</p>
<p>但是我们还是有三个问题没有考虑。</p>
<p>第一个是一些异常样本点或者说少量游离于簇外的样本点，这些点不在任何一个核心对象在周围，在DBSCAN中，我们一般将这些样本点标记为噪音点。</p>
<p>第二个是距离的度量问题，即如何计算某样本和核心对象样本的距离。在DBSCAN中，一般采用最近邻思想，采用某一种距离度量来衡量样本距离，比如欧式距离。这和KNN分类算法的最近邻思想完全相同。对应少量的样本，寻找最近邻可以直接去计算所有样本的距离，如果样本量较大，则一般采用KD树或者球树来快速的搜索最近邻。</p>
<p>第三种问题比较特殊，某些样本可能到两个核心对象的距离都小于ϵϵ，但是这两个核心对象由于不是密度直达，又不属于同一个聚类簇，那么如果界定这个样本的类别呢？
一般来说，此时DBSCAN采用先来后到，先进行聚类的类别簇会标记这个样本为它的类别。也就是说BDSCAN的算法不是完全稳定的算法。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="dbscan算法设计">DBSCAN算法设计<a href="https://2seekyou.github.io/zh-Hans/blog/DBSCAN#dbscan%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1" class="hash-link" aria-label="DBSCAN算法设计的直接链接" title="DBSCAN算法设计的直接链接">​</a></h2>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">DBSCAN(DB, distFunc, eps, minPts) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    C := 0                                                  /* Cluster counter */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for each point P in database DB {                       /*对数据集中的每个点处理*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if label(P) ≠ undefined then continue               /* Previously processed in inner loop */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Neighbors N := RangeQuery(DB, distFunc, P, eps)     /* Find neighbors */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if |N| &lt; minPts then {                              /* Density check */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            label(P) := Noise                               /* Label as Noise */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            continue</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        C := C + 1                                          /* 若满足簇数+1 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        label(P) := C                                       /* 用集群标签`C`标记当前点`P`。 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        SeedSet S := N \ {P}                                /* 我们初始化一个种子集 S ，其中包含 P 除其自身之外 P 的所有邻居。 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for each point Q in S {                             /* Process every seed point Q */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if label(Q) = Noise then label(Q) := C          /* Change Noise to border point */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if label(Q) ≠ undefined then continue           /* Previously processed (e.g., 如果是边界点) */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            label(Q) := C                                   /* 用集群标签C标记当前邻居点 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Neighbors N := RangeQuery(DB, distFunc, Q, eps) /* Find point Q's neighbors */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if |N| ≥ minPts then {                          /* 如果点Q的邻居数|N|大于或等于minPts，则表示它是核心点 minPts*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                S := S ∪ N                                  /* Add new neighbors to seed set */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="dbscan小结">DBSCAN小结<a href="https://2seekyou.github.io/zh-Hans/blog/DBSCAN#dbscan%E5%B0%8F%E7%BB%93" class="hash-link" aria-label="DBSCAN小结的直接链接" title="DBSCAN小结的直接链接">​</a></h2>
<p><strong>优点</strong></p>
<ul>
<li>不需要先验地指定数据中的簇数。</li>
<li>DBSCAN可以找到任意形状的簇。</li>
<li>DBSCAN 具有噪声的概念，并且对异常值具有鲁棒性。</li>
<li>DBSCAN设计用于可以加速区域查询的数据库，例如使用R*树。</li>
</ul>
<p><strong>缺点</strong></p>
<ol>
<li>DBSCAN 的质量取决于函数 <code>regionQuery(P，ε)</code> 中使用的距离测量值。最常用的距离度量是欧几里得距离。特别是对于高维数据，由于所谓的“维诅咒”，这个指标几乎毫无用处，很难找到合适的ε值。然而，这种效应也存在于任何其他基于欧几里得距离的算法中。</li>
<li>DBSCAN 在处理包含不同密度聚类的数据集时会遇到困难。它假设团簇具有均匀的密度，并且可能无法识别具有显着不同局部密度的团簇。</li>
<li>在最坏的情况下,DBSCAN的时间复杂度O(n^2)，即数据点的数量。对于大型数据集，可能很费时间，难以保证实时性。</li>
<li>DBSCAN 无法很好地聚类密度差异较大的数据集，因为无法为所有聚类适当选择 <code>minPts-ε</code> 组合</li>
</ol>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="dbscan扩展">DBSCAN扩展<a href="https://2seekyou.github.io/zh-Hans/blog/DBSCAN#dbscan%E6%89%A9%E5%B1%95" class="hash-link" aria-label="DBSCAN扩展的直接链接" title="DBSCAN扩展的直接链接">​</a></h2>
<p>Generalized DBSCAN (GDBSCAN) is a generalization by the same authors to arbitrary "neighborhood" and "dense" predicates.</p>
<p>The <code>ε</code> and <code>minPts</code> parameters are removed from the original algorithm and moved to the predicates. For example, on polygon data, the "neighborhood" could be any intersecting polygon, whereas the density predicate uses the polygon areas instead of just the object count.</p>
<p>Various extensions to the DBSCAN algorithm have been proposed, including methods for parallelization, parameter estimation, and support for uncertain data. The basic idea has been extended to hierarchical clustering by the OPTICS algorithm. DBSCAN is also used as part of subspace clustering algorithms like PreDeCon and SUBCLU.</p>
<p>HDBSCAN* is a hierarchical version of DBSCAN which is also faster than OPTICS, from which a flat partition consisting of the most prominent clusters can be extracted from the hierarchy.
<a href="https://wires.onlinelibrary.wiley.com/doi/full/10.1002/widm.30?saml_referrer" target="_blank" rel="noopener noreferrer">Reference</a></p>]]></content:encoded>
            <category>Note</category>
            <category>seekyou</category>
            <category>DBSCAN</category>
        </item>
        <item>
            <title><![CDATA[笔记：计算机缺失的一课]]></title>
            <link>https://2seekyou.github.io/zh-Hans/blog/The-Note-of-Missing-Semester</link>
            <guid>https://2seekyou.github.io/zh-Hans/blog/The-Note-of-Missing-Semester</guid>
            <pubDate>Tue, 27 Feb 2024 00:00:00 GMT</pubDate>
            <description><![CDATA[The Note of Missing Semester of CS Education]]></description>
            <content:encoded><![CDATA[<p>The Note of Missing Semester of CS Education</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="关于断更">关于断更:<a href="https://2seekyou.github.io/zh-Hans/blog/The-Note-of-Missing-Semester#%E5%85%B3%E4%BA%8E%E6%96%AD%E6%9B%B4" class="hash-link" aria-label="关于断更:的直接链接" title="关于断更:的直接链接">​</a></h2>
<p>github为什么断了一个多月？ 那必然是因为寒假在家实在是不方便办公，大病+太冷+事多。
近期抽空看完了之前只看了git那部分的课程，视频+课件参半看的差不多了。记录一些笔记，主要也是自己不太熟悉，以及感觉之后会用到的。附上链接<a href="https://openai.com/" target="_blank" rel="noopener noreferrer">MIT: Missing Semester of CS education</a></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="some-commad">some commad:<a href="https://2seekyou.github.io/zh-Hans/blog/The-Note-of-Missing-Semester#some-commad" class="hash-link" aria-label="some commad:的直接链接" title="some commad:的直接链接">​</a></h2>
<p><code>man + function</code> manual page of function<br>
<code>convert input.jpg output.png</code>:convert<br>
<code>touch {foo,bar}{a..j}</code> touch foo/a-j and bar/a-j(a,b,c,..)<br>
<code>diff &lt;(ls foo) &lt;(ls bar)</code>compare files in dir foo with bar<br>
<code>shellcheck a.sh</code><br>
<code>&gt; /dev/nul</code> 将命令的标准输出重定向到 /dev/null，任何标准输出都将被丢弃。<br>
<code>2&gt; /dev/null</code> 将命令的标准错误输出重定向到 /dev/null，任何错误消息都将被丢弃。<br>
<code>$?</code>输出上一个命令的错误代码<br>
<code>$_</code>输出上一个命令的最后一个参数<br>
<code>$0</code>当前运行的脚本名<br>
<code>$#</code>为当前命令提供的参数数量
<code>$$</code>为正在运行的命令的进程号<br>
<code>$@</code>将会扩展到所有的输入参数 $1 $2...<br>
<code>!!</code> 等效于上一个命令<br>
<code>ls ?.sh</code> find file with .sh and only one string
<code>ls */sh</code> find file with string and a .sh<br>
<code>tee</code> reads from the standard input and writes to both the standard output and one or more files simultaneously</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="resource-monitoring">Resource Monitoring<a href="https://2seekyou.github.io/zh-Hans/blog/The-Note-of-Missing-Semester#resource-monitoring" class="hash-link" aria-label="Resource Monitoring的直接链接" title="Resource Monitoring的直接链接">​</a></h3>
<p><code>htop</code>, which is an improved version of top. htop presents various statistics for the currently running processes on the system. htop has a myriad of options and keybinds, some useful ones are:</p>
<ul>
<li><code>&lt;F6&gt;</code> to sort processes,</li>
<li><code>t</code> to show tree hierarchy and h to toggle threads.</li>
<li><code>See also</code>glances for similar implementation with a great UI.</li>
<li><code>dstat</code> is another nifty tool that computes real-time resource metrics for lots of different subsystems like I/O, networking, CPU utilization, context switches, &amp;c.</li>
<li><code>iotop</code> displays live I/O usage information and is handy to check if a process is doing heavy I/O disk operations</li>
<li><code>lsof</code> lists file information about files opened by processes. It can be quite useful for checking which process has opened a specific file.</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="0-and-1">0 and 1<a href="https://2seekyou.github.io/zh-Hans/blog/The-Note-of-Missing-Semester#0-and-1" class="hash-link" aria-label="0 and 1的直接链接" title="0 and 1的直接链接">​</a></h3>
<p><code>echo "hello"</code> &gt;&gt; hello<br>
<code>echo $?</code> &gt;&gt; 0 ( because function run successfully )<br>
<code>grep foobar a.sh</code> &gt;&gt; (nothing)<br>
<code>echo $?</code> &gt;&gt; 1 (because fuction didn't realize so that return 1)<br>
<code>ture</code> &gt;&gt; (nothing)<br>
<code>echo $?</code> &gt;&gt; 0<br>
<code>false</code> &gt;&gt; (nothing)<br>
<code>echo $?</code> &gt;&gt; 0<br>
<code>"$?" -ne 0</code> for "non equal"<br>
<code>false || echo "oops fail"</code> &gt;&gt; oops fail (logic OR: if first didn't return 0 then try second )<br>
<code>ture || echo "fine"</code> &gt;&gt; (nothing)<br>
<code>cat &lt;(ls) &lt;(ls ..)</code> &gt;&gt; will print the file on present dir and its parent folder meanwhile</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="a-east-script">a east script<a href="https://2seekyou.github.io/zh-Hans/blog/The-Note-of-Missing-Semester#a-east-script" class="hash-link" aria-label="a east script的直接链接" title="a east script的直接链接">​</a></h3>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#!/usr/local/bin/python</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import sys</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">for arg in reversed(sys.argv[1:]):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print(arg)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>The kernel knows to execute this script with a python interpreter instead of a shell command because we included a shebang line at the top of the script.</p>
<p>It is good practice to write shebang lines using the <code>env</code> command that will resolve to wherever the command lives in the system, increasing the portability of your scripts. To resolve the location, <code>env</code> will make use of the PATH environment variable we introduced in the first lecture.</p>
<p>For this example the shebang line would look like <code>#!/usr/bin/env</code> python.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="shell-tools">shell tools<a href="https://2seekyou.github.io/zh-Hans/blog/The-Note-of-Missing-Semester#shell-tools" class="hash-link" aria-label="shell tools的直接链接" title="shell tools的直接链接">​</a></h3>
<p><code>tldr + function</code> a easy document for function with beautiful format<br>
<code>find . -name src -type d</code><br>
<code>fd ".*py"</code>equal to find<br>
<code>grep -R foobar .</code>find every foobar in present dir<br>
<code>rg "import requests" -t (-C 5) py ~/scratch </code>find all import requests in which line in dir of ~/scratch<br>
<!-- -->(-C 5 )<!-- -->:get<!-- --> 5 linesontext around import requests<br>
<code>fzf</code>is commonly used to streamline various command-line tasks, such as searching through files, navigating directories, selecting items from lists, and filtering command output.<br>
<code>broot</code> likely to <code>tree</code><br>
<code>less</code> likely to vim but mostly in viewing<br>
<code>sed + [option] + 'regular expresion' + [file] </code><br>
<code>tail [options] [file]</code>// Displays the last part of files<br>
<code>awk '{print $1}' file.txt</code>display first row of every line<br>
<code>echo "5 + 3" | bc -l</code><br>
<code>bc</code> caculator<br>
<code>-l</code> can loading math lib  to caculate more fuction and reply in decimal places</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="regular-expressions">Regular expressions<a href="https://2seekyou.github.io/zh-Hans/blog/The-Note-of-Missing-Semester#regular-expressions" class="hash-link" aria-label="Regular expressions的直接链接" title="Regular expressions的直接链接">​</a></h4>
<p>/.*Disconnected from /. Regular expressions are usually (though not always) surrounded by /
Very common patterns are:</p>
<p><code>.</code>means “any single character” except newline<br>
<code>*</code>zero or more of the preceding match<br>
<code>+</code> one or more of the preceding match<br>
<code>[abc]</code> any one character of a, b, and c<br>
<code>(RX1|RX2)</code> either something that matches RX1 or RX2<br>
<code>^</code> the start of the line<br>
<code>$</code> the end of the line</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="command-line-environment">Command-line Environment<a href="https://2seekyou.github.io/zh-Hans/blog/The-Note-of-Missing-Semester#command-line-environment" class="hash-link" aria-label="Command-line Environment的直接链接" title="Command-line Environment的直接链接">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="job-control">Job Control<a href="https://2seekyou.github.io/zh-Hans/blog/The-Note-of-Missing-Semester#job-control" class="hash-link" aria-label="Job Control的直接链接" title="Job Control的直接链接">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="killing-a-process">Killing a process<a href="https://2seekyou.github.io/zh-Hans/blog/The-Note-of-Missing-Semester#killing-a-process" class="hash-link" aria-label="Killing a process的直接链接" title="Killing a process的直接链接">​</a></h4>
<p><code>Ctrl-C</code> SIGINT signal<br>
<code>Ctrl-\.</code>SIGQUIT signal</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="pausing-and-backgrounding-processes">Pausing and backgrounding processes<a href="https://2seekyou.github.io/zh-Hans/blog/The-Note-of-Missing-Semester#pausing-and-backgrounding-processes" class="hash-link" aria-label="Pausing and backgrounding processes的直接链接" title="Pausing and backgrounding processes的直接链接">​</a></h4>
<p><code>jobs</code> show all the process stats<br>
<code>Ctrl-Z</code> prompt the shell to send a <code>SIGTSTP</code> signal to stop lprocess<br>
<!-- -->Then can use <code>fg</code> <code>bg %n</code> to continue the work in foreground or background(n is the job num of process shown by <code>jobs</code>so we don't need too remenber pid num)<br>
<code>nohup sleep 200 &amp;</code> hang up on background and ignore the hangup signal</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="terminal-multiplexers">Terminal Multiplexers<a href="https://2seekyou.github.io/zh-Hans/blog/The-Note-of-Missing-Semester#terminal-multiplexers" class="hash-link" aria-label="Terminal Multiplexers的直接链接" title="Terminal Multiplexers的直接链接">​</a></h4>
<p><code>tmux</code> likely to <code>screen</code> use<code>ctrl + B/A</code> as same as opening 2 terminal while using mostly in remote computer because it can aviod the hangup signal like what we mentioned before</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="aliases">Aliases<a href="https://2seekyou.github.io/zh-Hans/blog/The-Note-of-Missing-Semester#aliases" class="hash-link" aria-label="Aliases的直接链接" title="Aliases的直接链接">​</a></h3>
<p><code>alias ll= "ls -lah"</code>  can be mdoify in .bashrc in order to keep all terminal</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="dotfiles">Dotfiles<a href="https://2seekyou.github.io/zh-Hans/blog/The-Note-of-Missing-Semester#dotfiles" class="hash-link" aria-label="Dotfiles的直接链接" title="Dotfiles的直接链接">​</a></h3>
<p>Many programs are configured using plain-text files known as dotfiles (because the file names begin with a ., e.g. ~/.vimrc<br>
<!-- -->In fact, many programs will ask you to include a line like export PATH="$PATH:/path/to/program/bin" in your shell configuration file so their binaries can be found by bash.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="remote-machines">Remote Machines<a href="https://2seekyou.github.io/zh-Hans/blog/The-Note-of-Missing-Semester#remote-machines" class="hash-link" aria-label="Remote Machines的直接链接" title="Remote Machines的直接链接">​</a></h3>
<p><code>ssh foo@bar.mit.edu</code><br>
<code>Mosh</code> the mobile shell, improves upon ssh</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="ssh-copt-file">SSH copt file<a href="https://2seekyou.github.io/zh-Hans/blog/The-Note-of-Missing-Semester#ssh-copt-file" class="hash-link" aria-label="SSH copt file的直接链接" title="SSH copt file的直接链接">​</a></h4>
<p><code>cat localfile | ssh remote_server tee serverfile</code>copt localfile paste to remote server<br>
<code>scp local_file remote_user@remote_host:remote_path</code>supports transferring both files and directories between local and remote servers, and you can use the -r option for recursive copying.<br>
<code>rsync -avz local_directory/ remote_user@remote_host:remote_directory</code>used to sync files and directories between a local computer and a remote server.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="potpourri-">Potpourri :<a href="https://2seekyou.github.io/zh-Hans/blog/The-Note-of-Missing-Semester#potpourri-" class="hash-link" aria-label="Potpourri :的直接链接" title="Potpourri :的直接链接">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="daemons">Daemons<a href="https://2seekyou.github.io/zh-Hans/blog/The-Note-of-Missing-Semester#daemons" class="hash-link" aria-label="Daemons的直接链接" title="Daemons的直接链接">​</a></h3>
<p>In Linux, systemd (the system daemon) is the most common solution for running and setting up daemon processes.<br>
<!-- -->You can run systemctl status to list the current running daemons.Systemd can be interacted with the systemctl command in order to enable, disable, start, stop, restart or check the status of services (those are the systemctl commands).</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="fuse">FUSE<a href="https://2seekyou.github.io/zh-Hans/blog/The-Note-of-Missing-Semester#fuse" class="hash-link" aria-label="FUSE的直接链接" title="FUSE的直接链接">​</a></h3>
<p>Some interesting examples of FUSE filesystems are:</p>
<ul>
<li>sshfs - Open locally remote files/folder through an SSH connection.</li>
<li>rclone - Mount cloud storage services like Dropbox, GDrive, Amazon S3 or Google Cloud Storage and open data locally.</li>
<li>gocryptfs - Encrypted overlay system. Files are stored encrypted but once the FS is mounted they appear as plaintext in the mountpoint.</li>
<li>kbfs - Distributed filesystem with end-to-end encryption. You can have private, shared and public folders.</li>
<li>borgbackup - Mount your deduplicated, compressed and encrypted backups for ease of browsing.</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="common-command-line-flagspatterns">Common command-line flags/patterns<a href="https://2seekyou.github.io/zh-Hans/blog/The-Note-of-Missing-Semester#common-command-line-flagspatterns" class="hash-link" aria-label="Common command-line flags/patterns的直接链接" title="Common command-line flags/patterns的直接链接">​</a></h3>
<p>Almost all tools have a --verbose or -v flag to produce more verbose output. You can usually include the flag multiple times (-vvv) to get more verbose output, which can be handy for debugging. Similarly, many tools have a --quiet flag for making it only print something on error.</p>]]></content:encoded>
            <category>Note</category>
            <category>seekyou</category>
            <category>2024</category>
        </item>
        <item>
            <title><![CDATA[2023·年度总结]]></title>
            <link>https://2seekyou.github.io/zh-Hans/blog/2023-sum-up-1</link>
            <guid>https://2seekyou.github.io/zh-Hans/blog/2023-sum-up-1</guid>
            <pubDate>Sun, 31 Dec 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[2023年即将接近尾声，在此写下20年人生中的第一次年度总结。]]></description>
            <content:encoded><![CDATA[<p>2023年即将接近尾声，在此写下20年人生中的第一次年度总结。</p>
<p>自来上海以来，近期算是我最闲暇的时光，正好可以搭自己的博客，做自己想做的一些事情，顺便记录一下我的2023年。（多图警告！）</p>
<p>自从上大学以来已经有三年半载了。如果不算大四这年（实习，找工作，考研，保研），相当于我大学的主要生涯也确实是结束了。突然感觉时间过的好快，一下我就成学长了，我也快毕业了，我也20出头了。</p>
<p>因此在此做下我2023年度的总结，顺带设想一下2024的一年。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="2023起点还是终点">2023·起点还是终点<a href="https://2seekyou.github.io/zh-Hans/blog/2023-sum-up-1#2023%E8%B5%B7%E7%82%B9%E8%BF%98%E6%98%AF%E7%BB%88%E7%82%B9" class="hash-link" aria-label="2023·起点还是终点的直接链接" title="2023·起点还是终点的直接链接">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="比赛--保研的选择">比赛 + 保研的选择<a href="https://2seekyou.github.io/zh-Hans/blog/2023-sum-up-1#%E6%AF%94%E8%B5%9B--%E4%BF%9D%E7%A0%94%E7%9A%84%E9%80%89%E6%8B%A9" class="hash-link" aria-label="比赛 + 保研的选择的直接链接" title="比赛 + 保研的选择的直接链接">​</a></h3>
<p>对于今年的参赛安排，我个人也是相当矛盾的。一方面是由于去年的A类国一和国二使我已经获得了保研资格，只是绩点太低，并不能确定我是保内还是保外。另一方面是要不要尝试争取一下国特，如果能拿到绩点对我就没有影响了，但是难度嘛。。。</p>
<p>上半年也算是我比较迷茫的时期。一方面绩点摆在这里，今年就算全部的科目满绩点也大概不能保证达到保外的要求，因此我大概率是保本校的。但是我自己又不太想留在本校，但是面对考研我没有做好足够的心理准备，这件事情属实令我困扰了很久，甚至萌生了要不要降级去刷一年绩点的想法。当然这个想法遭到除了同学以外所有人的反对。原因各式各样，就不细说了。</p>
<p>同时期父母唠叨不停，希望我边把本学期绩点搞好，边参加比赛，边准备考研的复习。显然是不太可能的。唯独最后者我不太上心，因为时间的问题，我此时的计划只准备线上赛，线下全权交给学弟和组长。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="全模型线上赛">全模型线上赛<a href="https://2seekyou.github.io/zh-Hans/blog/2023-sum-up-1#%E5%85%A8%E6%A8%A1%E5%9E%8B%E7%BA%BF%E4%B8%8A%E8%B5%9B" class="hash-link" aria-label="全模型线上赛的直接链接" title="全模型线上赛的直接链接">​</a></h3>
<p>因此，虽然此时我有打算考研考出去，但是没有做好足够的心理准备，也是借着竞赛的理由奔波在实验室，甚至就把实验室当宿舍。</p>
<p>每日三点一线般的准备着：1比赛2绩点3考研。显然最后一者是我相当排斥的，所以准备也就最少。而比赛上打算想我之前的学长学习，就一口气报了好几个，大疆天途无人机组，百度完全模型组，智能机器人啥的几乎能报的都报了个遍。</p>
<p>而前期的准备对我来说也是一种别样的学习。由于去年的线上赛全程都是我的学长在做，所有我几乎是从零开始学习用aistudio调参，怎么训练模型，怎么用脚本后台任务挂机。所幸在跑了大概1个多月后，也查看了很多大佬的一些项目baseline讲解，加上各种多尺度，调阈值，换模型，数据增强，模型的score达到了排行榜的第十名。除去最上面的一些重复的账号，应该排在第五了。</p>
<p>或许我也没想到，自从这之后，模型的F1-score就再也没能提上去了。最终定格在74名。但是在整个华南赛区大概是前5，也还算比较满意了哈哈。（实际也只有区赛会算一点线上赛的分数）</p>
<p>报这些组别其实有一个很吸引我的点，因为我对单片机并没有那么熟悉，大多数时候都是用的一些基本功能，而用ubuntu系统和各式各样的边缘计算设备总给我一种很高级的感觉（因为贵）。这段时间也算是更加熟悉了一些有意思的东西，例如用贝叶斯曲线做曲线拟合，用霍夫检测视频帧里的固定形状，多线程去同时运行目标检测和姿态控制。</p>
<p>虽说原理还不是很理解，就像哪些自动控制原理或者现代控制原理书上那些苦涩难懂的公式一样，我并不打算去深入理解其含义，也不需要去理解那么深入，只要代码能运行，车子能跑，对比赛来说跑的好就行。这样的唯结果论是我目前最赞同的。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="设备租借备赛">设备租借备赛<a href="https://2seekyou.github.io/zh-Hans/blog/2023-sum-up-1#%E8%AE%BE%E5%A4%87%E7%A7%9F%E5%80%9F%E5%A4%87%E8%B5%9B" class="hash-link" aria-label="设备租借备赛的直接链接" title="设备租借备赛的直接链接">​</a></h3>
<p>我其实非常疑惑，这种技术性的竞赛，免费租借的名额竟然是靠一个赛季规划文档来决定的，对我来说的就像是自动化专业天天学ppt怎么做，怎么好看怎么拿奖。这种行为还被学校的大多数人校所支持，一堆人搞着哪些所谓的大创，不知道用着多少年前的项目，不断得增添各种花里胡哨的功能，甚至原封不动上交，拿个优秀结题，或者什么大创的奖，然后综测和保研嘎嘎加分。</p>
<p>在我看来这种行为需要的只是机灵而已，根本就不需要具体做些什么东西，即使我也做过类似的大创，但是也并不觉得光彩，只是一些学长赚钱的工具罢了。我承认这些项目中确实有那种有些技术性的东西在，但是甚至比不过滥竽充数的大多数。
所幸借助着学弟和Chatgpt的力量，线上文档成绩在前30直接免费get大疆无人机和rm小车租借资格！</p>
<p>大疆M3e</p>
<p><img loading="lazy" src="https://ooo.0x0.ooo/2024/01/16/OvBUyL.png" alt="OvBUyL.png" class="img_ev3q"></p>
<p>大疆RMEP</p>
<p><img loading="lazy" src="https://ooo.0x0.ooo/2024/01/16/OvBTUC.jpg" alt="OvBTUC.jpg" class="img_ev3q"></p>
<p>正好机器人线上赛去年也是我的学长做的，今年开始自己学着用python写几个简单的图像处理demo，拿个60分还是不算太难。也上传了github <a href="https://github.com/cowqer/2023international-online-competition-of-auto-running-robots" target="_blank" rel="noopener noreferrer">here！</a> 因为写的比较简单，所以也没在意细节，反正也只是反复提交和刷分。</p>
<p>题目的内容几乎都是对赛道上的一些简单图像做元素识别，输出目标图形的圆心和半径，或者是多边形的中心点坐标和长宽。并不算太复杂，但是要多提交比对，因为参考数据比较少，验证集大概也只有20多个吧,大多数的图像学和边缘检测加上多边形检测就基本够用了。</p>
<p><img loading="lazy" alt="7.jpg" src="https://2seekyou.github.io/zh-Hans/assets/images/7-96960957eb31be429b47e4eb77f6a738.jpg" width="505" height="364" class="img_ev3q"></p>
<p>两台小机器人</p>
<p>上文说到我此时的计划只准备线上赛，线下全权交给学弟和组长。但是事实是组长直接开头到结尾没来过，硬件也差不多，几乎就学弟一个人在搞。我自己也想以比赛为借口逃避考研，也有想借着无人机大赛冲刺国特，直接保外的想法。虽然我知道我自己的任务已经完成了，但是整个组毕竟在这里，我做不出来半途而废的举动，也不想整个组就此解散，我也没有办法，我也不是这种性格。</p>
<p>或许比赛对我的意义已经不打了，但是在我看来，这是我的提议才有的组别，这是我起初识人有误才导致的结果，我应该要负起这个责任。总而言之就是依旧在比赛上又花了不少心思，自己又重新成了组长开始一点点接手，重新拉人一起做硬件，帮着和学弟一起调车一起熬夜。</p>
<p>顺便还看到隔壁计网院的考研上岸率···我看着就感觉到害怕，也更不想去复习了。
（只存在了一天，怀疑是觉得不太光荣就被撕掉了）</p>
<p><img loading="lazy" src="https://ooo.0x0.ooo/2024/01/16/OvBWsi.jpg" alt="OvBWsi.jpg" class="img_ev3q"></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="确定保研之后">确定保研之后<a href="https://2seekyou.github.io/zh-Hans/blog/2023-sum-up-1#%E7%A1%AE%E5%AE%9A%E4%BF%9D%E7%A0%94%E4%B9%8B%E5%90%8E" class="hash-link" aria-label="确定保研之后的直接链接" title="确定保研之后的直接链接">​</a></h2>
<p>即使这学期的绩点几乎满绩，但最终排名定格还差10名左右。没能保送外校。但是我也做好了心理准备，也接受了事实，还安慰自己没事，反正本校老师啥都熟，以后出去读博什么的也方便。
而且这个时候的比赛还在继续，要达到89月份的话也没什么备考时间留给我了，我也就顺利成章成功地逃避考研继续之后的比赛。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="旅游--比赛-1">旅游 + 比赛 1<a href="https://2seekyou.github.io/zh-Hans/blog/2023-sum-up-1#%E6%97%85%E6%B8%B8--%E6%AF%94%E8%B5%9B-1" class="hash-link" aria-label="旅游 + 比赛 1的直接链接" title="旅游 + 比赛 1的直接链接">​</a></h3>
<p>在完全模型的华南区赛结束后，我们马上开始准备了无人机组的重庆西部赛区比赛，时间很短，满打满算可能也不超过5天的备赛时间。
几乎是天天通宵，一口气都没歇过直奔重庆。好在线下的比赛难度不是很大，简单的完赛还是做到了，国二GET！也就顺理成章地正式进入完赛后的旅游环节！
<img loading="lazy" src="https://ooo.0x0.ooo/2024/01/16/OvBkaX.jpg" alt="OvBkaX.jpg" class="img_ev3q"></p>
<p>来都来了，重庆火锅总得试试吧</p>
<p><img loading="lazy" src="https://ooo.0x0.ooo/2024/01/16/OvBxet.jpg" alt="OvBxet.jpg" class="img_ev3q"></p>
<p>重庆最高点的夜景</p>
<p><img loading="lazy" src="https://ooo.0x0.ooo/2024/01/16/OvBqRS.jpg" alt="OvBqRS.jpg" class="img_ev3q"></p>
<p>顺带也去了一趟成都，四川的麻辣豆花，very nice！</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="旅游--比赛-2">旅游 + 比赛 2<a href="https://2seekyou.github.io/zh-Hans/blog/2023-sum-up-1#%E6%97%85%E6%B8%B8--%E6%AF%94%E8%B5%9B-2" class="hash-link" aria-label="旅游 + 比赛 2的直接链接" title="旅游 + 比赛 2的直接链接">​</a></h3>
<p>最意想不到的事情是又进了国赛···原本打算放暑假了，卓大发的推文出来，卡线华南最后一名进国赛了。所以又加上一段智能车国赛·天津之旅。
<img loading="lazy" src="https://ooo.0x0.ooo/2024/01/16/OvBzGx.jpg" alt="OvBzGx.jpg" class="img_ev3q"></p>
<p>天津工业大学</p>
<p>但是由于中途的一些小插曲————百度飞桨的夏季峰会wave summit正好在比赛前一天的北京举行，而之前大疆组又碰巧要开一个开发者会议，在比赛结束3天后的深圳天空之城举行。
<img loading="lazy" src="https://ooo.0x0.ooo/2024/01/16/OvBoha.jpg" alt="OvBoha.jpg" class="img_ev3q"></p>
<p>峰会现场</p>
<p><img loading="lazy" src="https://ooo.0x0.ooo/2024/01/16/OvBihp.jpg" alt="OvBihp.jpg" class="img_ev3q"></p>
<p>大疆天空之城</p>
<p>所以这段就变成北京-天津-深圳之旅。总而言之就是通过比赛，我几乎跑遍全国主要的东西南北——南京 成都 深圳 北京。最后旅途结束时收获满满一把车票!!</p>
<p><img loading="lazy" src="https://ooo.0x0.ooo/2024/01/16/OvBFIj.jpg" alt="OvBFIj.jpg" class="img_ev3q"></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="上半年总结">上半年总结<a href="https://2seekyou.github.io/zh-Hans/blog/2023-sum-up-1#%E4%B8%8A%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93" class="hash-link" aria-label="上半年总结的直接链接" title="上半年总结的直接链接">​</a></h2>
<p>上半年其实并不只是展现在这里的风光，也有很多七七八八的烦心事或者说觉得做的很差的地方。为什么这么说呢？因为我上半年几乎都没有认真的学习过。</p>
<p>当然我指的是技术方面，学校的课程我还是有认真准备复习的😅。比赛几个月中途用到的许多东西都是在已有的基础上进行二次开发或者只是繁琐的PID调参，对我个人来说并没有真正学习到有用的技术，或者说思想上有什么很大的突破。</p>
<p>加上去年年底出来的chatgpt，我就变得更懒惰了，反而不会像以前一样认认真真去看他人的博客，长期性不加思考的cv大法让我觉得相当空虚，有一种仿佛什么都学了但是什么都没有学到的感觉。虽然在没出现gpt之前我也有过类似的行为，但有一些遇到的问题还是会自己思考，去想办法搞懂。但是现在就算是出现了什么问题我也只是把问题再抛给gpt，让他去思考。仿佛成了一个只会复制粘贴的工具人···
<img loading="lazy" src="https://ooo.0x0.ooo/2024/01/16/Ov5cvc.jpg" alt="20.jpg" class="img_ev3q"></p>
<p>我不得不承认gpt的出现大幅度提升了我的工作效率，借着gpt的力量今年我才能在很多地方领先一步其他快一年还有人不知道gpt的人。我也喜欢借着一些类似的语言麻痹自己，让自己心安：这种东西只能算是工具罢了，我使用的工具产生的生产结果为什么不能算我的个人所获呢？举个例子，我用gpt生产的论文为什么不算我自己的呢？</p>
<p>这样一番话看似冠冕堂皇，但是也存在一些悖论在其中，就是关于gpt的定义是否真的只是工具？一旦他的生产效益过大，超过了简单的工具定义，例如现在github上一些利用gpt生成大型项目的开源项目，这样庞大的生产效益，但是你只需要提供几个关键词prompt说的详细，总感觉有些过于玄乎。</p>
<p>不下于哈利波特中的魔咒一般，10个字母不到就能变得如此神奇。而需要的只不过是想象力罢了——很相像对吧？就是这么神奇，对现在的我来说感觉到相当恐惧，仿佛以后只需要人们会写prompt去生产代码，根据效果再反馈给他改进，运行测试过程的bug就反复抛给他就行——而实际上我早已经开始这么做了···</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="2023终点站上海">2023终点站·上海<a href="https://2seekyou.github.io/zh-Hans/blog/2023-sum-up-1#2023%E7%BB%88%E7%82%B9%E7%AB%99%E4%B8%8A%E6%B5%B7" class="hash-link" aria-label="2023终点站·上海的直接链接" title="2023终点站·上海的直接链接">​</a></h2>
<p>下半年可以理解为在上海的一段小实习经历，美其名曰在上交做科研助理，实际不过是在这边打点什么杂活。但是也有不少收获——对Linux系统，C++，实际Project的理解又进了一步。</p>
<p>大约在一年前，我的学长曾告诉过我很多工作要用的东西可以提前学习熟悉。例如git这种版本管理工具，在那种长期的比赛中是相当实用的，比起我一直以来的复制粘贴高效多了。例如叫我用一些前端框架搭建个人博客，只是我当时完全听不懂他在讲什么，太多东西都是我没听过的，差距太大宛如我上周在交大听毕业博士学姐的学术汇报，从题目开始就没听懂过——还是中文的。很多东西你越是想理解，你就越累越会犯困。</p>
<p>现在想想也挺后悔的。之前学长的好多意见我都没有采纳。想着靠学长，靠他人。自己却从没认真从头做起，导致对很多东西一知半解。问起来还是得百度或者gpt。</p>
<p>学校自然也不会告诉你目前这个专业工作环境中常用的一些技术，很多人学个C语言到if for while就结束了，其他的什么底层，单片机的各种函数都只是死记硬背，为考试混个好分数罢了。</p>
<p>当然，我也不例外。好在本次上海之旅还是有不少收获的。首先是正式开始使用github，git和gitlab。熟悉了常规小项目的管理形式，虽然有一些地方还不熟悉。其次是了解有关库移植，交叉编译——真是让人非常烦恼的事情。docker——稍有接触。从某种意义上算是打开了新世界的大门，发现了更多的信息。</p>
<p>这是我在学校里打两年比赛所不能及的。虽然我认为这样的基础知识去实习大概率还是可以学到，但是我的原计划中暂时还没有包括这一段。很多新鲜的想法。各种新鲜工具的使用，都是来这里之后才有的。真不戳，虽然在人与人日常交流和生活中也有一些让人不愉快的地方，但是勉强还可以接受。</p>
<iframe src="//player.bilibili.com/player.html?aid=705508583&amp;bvid=BV1PQ4y1n7ih&amp;cid=1323057440&amp;p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe>
<p>一点小记录</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="后谈">后谈<a href="https://2seekyou.github.io/zh-Hans/blog/2023-sum-up-1#%E5%90%8E%E8%B0%88" class="hash-link" aria-label="后谈的直接链接" title="后谈的直接链接">​</a></h2>
<p>很多时候我自己认为的坏事可能不一定是坏事，不能总是局限于当下私认为。等过了半年，一年以一个事后的角度来看，貌似也没那么差。以我自己的经历来看，我们无时不刻不在做着各种各样的选择，时好时坏，但是是好是坏并不是当时就能看出来的。一旦做出了抉择，就不要后悔。做好当下之事，以待转机并且牢牢抓住它。这也是我这一年总结下来的经验。</p>
<p>很喜欢这句话，看似安身守命，以待天时。实则以不变应万变，韬光养晦，厚积而薄发。望与诸君共勉！</p>
<blockquote>
<p>大丈夫行于乱世，当光明磊落，即使处于逆境，也当屈身守分，以待天时，不可与命抗争也。</p>
</blockquote>
<p>——刘备</p>]]></content:encoded>
            <category>summary</category>
            <category>seekyou</category>
            <category>2023</category>
        </item>
        <item>
            <title><![CDATA[欢迎来到SeekYou！]]></title>
            <link>https://2seekyou.github.io/zh-Hans/blog/Welcome-to-seekyous-blog</link>
            <guid>https://2seekyou.github.io/zh-Hans/blog/Welcome-to-seekyous-blog</guid>
            <pubDate>Fri, 15 Dec 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[欢迎来到崔的小站]]></description>
            <content:encoded><![CDATA[<p><strong>欢迎来到崔的小站</strong></p>]]></content:encoded>
            <category>welcome</category>
        </item>
    </channel>
</rss>